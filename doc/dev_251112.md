# Deduction 模块开发计划

**创建时间**: 2025-11-12
**模块名称**: Deduction (推导执行模块)
**优先级**: 高
**预计工期**: 2-3周

---

## 一、模块概述

### 1.1 功能定位
Deduction 模块是系统的核心执行引擎，负责：
- 接收前端配置的智能体方案并启动执行
- 与 Engine 服务交互，提交和管理执行任务
- 实时监控智能体执行状态和日志
- 支持方案的动态更新和停止
- 为前端提供执行状态和日志查询接口

### 1.2 核心业务流程

```
【启动流程】
前端配置方案 → POST /deduction/create → 创建任务 → 调用 Engine API → 启动后台监控

【监控流程】
后台定时任务 → 查询运行中任务 → 调用 Engine 查询接口 → 更新数据库 → 前端轮询/WebSocket 获取

【更新流程】
前端修改方案 → PUT /deduction/{id}/update → 更新数据库 → 调用 Engine 更新接口

【停止流程】
前端点击停止 → POST /deduction/{id}/stop → 调用 Engine 停止接口 → 更新任务状态
```

---

## 二、数据库设计

### 2.1 表结构设计

#### 表1: `deduction_task` (推导任务表)

**用途**: 记录每次方案执行的任务信息

```python
class DeductionTask(Base):
    """推导任务表"""
    __tablename__ = "deduction_task"

    # 主键和外键
    id: Mapped[snowflake_id_key] = mapped_column(sa.BigInteger, primary_key=True, comment="任务ID")
    scheme_id: Mapped[int] = mapped_column(sa.BigInteger, sa.ForeignKey("scheme.id"), comment="方案ID")
    env_instance_id: Mapped[int] = mapped_column(sa.BigInteger, sa.ForeignKey("env_instance.id"), comment="环境实例ID")

    # 任务基本信息
    name: Mapped[str] = mapped_column(sa.String(128), unique=True, comment="任务名称")
    description: Mapped[str | None] = mapped_column(sa.String(512), nullable=True, comment="任务描述")

    # 状态管理
    status: Mapped[str] = mapped_column(
        sa.String(32),
        default="pending",
        comment="任务状态: pending/running/completed/failed/stopped"
    )

    # Engine 交互
    engine_task_id: Mapped[str | None] = mapped_column(sa.String(128), nullable=True, comment="引擎侧任务ID")
    engine_url: Mapped[str | None] = mapped_column(sa.String(256), nullable=True, comment="Engine服务地址")

    # 方案快照（冗余存储，避免原方案修改影响历史记录）
    scheme_snapshot: Mapped[dict] = mapped_column(sa.JSON, comment="方案配置快照")

    # 时间字段
    start_time: Mapped[datetime | None] = mapped_column(TimeZone, nullable=True, comment="开始时间")
    end_time: Mapped[datetime | None] = mapped_column(TimeZone, nullable=True, comment="结束时间")

    # 统计信息
    total_agents: Mapped[int] = mapped_column(sa.Integer, default=0, comment="智能体总数")
    completed_agents: Mapped[int] = mapped_column(sa.Integer, default=0, comment="已完成智能体数")
    failed_agents: Mapped[int] = mapped_column(sa.Integer, default=0, comment="失败智能体数")

    # 错误信息
    error_message: Mapped[str | None] = mapped_column(sa.Text, nullable=True, comment="错误信息")

    # 审计字段
    create_at: Mapped[datetime] = mapped_column(TimeZone, default=timezone_now, comment="创建时间")
    update_at: Mapped[datetime] = mapped_column(TimeZone, default=timezone_now, onupdate=timezone_now, comment="更新时间")
```

**索引设计**:
```sql
CREATE INDEX idx_deduction_task_status ON deduction_task(status);
CREATE INDEX idx_deduction_task_scheme_id ON deduction_task(scheme_id);
CREATE INDEX idx_deduction_task_create_at ON deduction_task(create_at);
```

---

#### 表2: `agent_execution` (智能体执行实例表)

**用途**: 记录每个智能体在任务中的执行情况

```python
class AgentExecution(Base):
    """智能体执行实例表"""
    __tablename__ = "agent_execution"

    # 主键和外键
    id: Mapped[snowflake_id_key] = mapped_column(sa.BigInteger, primary_key=True, comment="执行实例ID")
    deduction_task_id: Mapped[int] = mapped_column(
        sa.BigInteger,
        sa.ForeignKey("deduction_task.id", ondelete="CASCADE"),
        comment="所属任务ID"
    )
    agent_meta_id: Mapped[int] = mapped_column(
        sa.Integer,
        sa.ForeignKey("agent_meta.id"),
        comment="智能体元数据ID"
    )

    # 智能体信息（冗余字段，便于查询）
    agent_name: Mapped[str] = mapped_column(sa.String(64), comment="智能体名称")
    agent_load: Mapped[str] = mapped_column(sa.String(128), comment="智能体加载名称")
    side: Mapped[str] = mapped_column(sa.String(64), comment="阵营")

    # 配置参数
    params: Mapped[dict] = mapped_column(sa.JSON, comment="智能体配置参数")

    # 执行状态
    status: Mapped[str] = mapped_column(
        sa.String(32),
        default="pending",
        comment="执行状态: pending/running/completed/failed/stopped"
    )

    # Engine 交互
    engine_agent_id: Mapped[str | None] = mapped_column(sa.String(128), nullable=True, comment="引擎侧智能体ID")

    # 执行进度
    progress: Mapped[int] = mapped_column(sa.Integer, default=0, comment="执行进度(0-100)")

    # 时间字段
    start_time: Mapped[datetime | None] = mapped_column(TimeZone, nullable=True, comment="开始时间")
    end_time: Mapped[datetime | None] = mapped_column(TimeZone, nullable=True, comment="结束时间")

    # 执行结果
    result: Mapped[dict | None] = mapped_column(sa.JSON, nullable=True, comment="执行结果")
    error_message: Mapped[str | None] = mapped_column(sa.Text, nullable=True, comment="错误信息")

    # 重试信息
    retry_count: Mapped[int] = mapped_column(sa.Integer, default=0, comment="重试次数")
    max_retry: Mapped[int] = mapped_column(sa.Integer, default=3, comment="最大重试次数")

    # 审计字段
    create_at: Mapped[datetime] = mapped_column(TimeZone, default=timezone_now, comment="创建时间")
    update_at: Mapped[datetime] = mapped_column(TimeZone, default=timezone_now, onupdate=timezone_now, comment="更新时间")
```

**索引设计**:
```sql
CREATE INDEX idx_agent_execution_task_id ON agent_execution(deduction_task_id);
CREATE INDEX idx_agent_execution_status ON agent_execution(status);
CREATE INDEX idx_agent_execution_task_status ON agent_execution(deduction_task_id, status);
```

---

#### 表3: `agent_execution_log` (智能体执行日志表)

**用途**: 记录智能体执行过程中的日志信息

```python
class AgentExecutionLog(Base):
    """智能体执行日志表"""
    __tablename__ = "agent_execution_log"

    # 主键和外键
    id: Mapped[int] = mapped_column(sa.BigInteger, sa.Identity(start=1, increment=1), primary_key=True, comment="日志ID")
    agent_execution_id: Mapped[int] = mapped_column(
        sa.BigInteger,
        sa.ForeignKey("agent_execution.id", ondelete="CASCADE"),
        comment="执行实例ID"
    )

    # 日志信息
    timestamp: Mapped[datetime] = mapped_column(TimeZone, comment="日志时间戳")
    level: Mapped[str] = mapped_column(sa.String(16), comment="日志级别: DEBUG/INFO/WARNING/ERROR/CRITICAL")
    message: Mapped[str] = mapped_column(sa.Text, comment="日志内容")

    # 日志来源
    source: Mapped[str | None] = mapped_column(sa.String(64), nullable=True, comment="日志来源模块")

    # 附加数据
    extra_data: Mapped[dict | None] = mapped_column(sa.JSON, nullable=True, comment="额外数据")

    # 审计字段
    create_at: Mapped[datetime] = mapped_column(TimeZone, default=timezone_now, comment="创建时间")
```

**索引设计**:
```sql
CREATE INDEX idx_agent_log_execution_id ON agent_execution_log(agent_execution_id);
CREATE INDEX idx_agent_log_timestamp ON agent_execution_log(timestamp);
CREATE INDEX idx_agent_log_level ON agent_execution_log(level);
```

---

#### 表4: `deduction_task_history` (任务变更历史表)

**用途**: 记录任务配置的变更历史（可选，用于审计和回溯）

```python
class DeductionTaskHistory(Base):
    """任务变更历史表"""
    __tablename__ = "deduction_task_history"

    # 主键和外键
    id: Mapped[int] = mapped_column(sa.BigInteger, sa.Identity(start=1, increment=1), primary_key=True, comment="历史记录ID")
    deduction_task_id: Mapped[int] = mapped_column(
        sa.BigInteger,
        sa.ForeignKey("deduction_task.id", ondelete="CASCADE"),
        comment="任务ID"
    )

    # 变更信息
    change_type: Mapped[str] = mapped_column(
        sa.String(32),
        comment="变更类型: config_update/status_change/stop_request/agent_update"
    )
    change_description: Mapped[str | None] = mapped_column(sa.String(256), nullable=True, comment="变更描述")

    # 变更内容
    old_value: Mapped[dict | None] = mapped_column(sa.JSON, nullable=True, comment="旧值")
    new_value: Mapped[dict | None] = mapped_column(sa.JSON, nullable=True, comment="新值")

    # 变更时间和操作者
    change_time: Mapped[datetime] = mapped_column(TimeZone, default=timezone_now, comment="变更时间")
    operator: Mapped[str | None] = mapped_column(sa.String(64), nullable=True, comment="操作者")

    # 审计字段
    create_at: Mapped[datetime] = mapped_column(TimeZone, default=timezone_now, comment="创建时间")
```

**索引设计**:
```sql
CREATE INDEX idx_task_history_task_id ON deduction_task_history(deduction_task_id);
CREATE INDEX idx_task_history_change_time ON deduction_task_history(change_time);
```

---

### 2.2 表关系图

```
deduction_task (1)
    ├─→ (N) agent_execution
    │       └─→ (N) agent_execution_log
    └─→ (N) deduction_task_history

deduction_task ──FK──> scheme (方案表)
deduction_task ──FK──> env_instance (环境实例表)
agent_execution ──FK──> agent_meta (智能体元数据表)
```

---

## 三、API 接口设计

### 3.1 任务管理接口

#### 3.1.1 创建推导任务
```http
POST /api/v1/deduction/task/create
Content-Type: application/json

Request Body:
{
  "name": "task_20251112_001",
  "description": "红蓝对抗演练任务",
  "scheme_id": 1234567890,
  "env_instance_id": 9876543210,
  "agent_configs": [
    {
      "agent_meta_id": 10001,
      "side": "red",
      "params": {
        "attack_strategy": "aggressive",
        "target": "192.168.1.100"
      }
    },
    {
      "agent_meta_id": 10002,
      "side": "blue",
      "params": {
        "defense_level": "high"
      }
    }
  ]
}

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "task_id": 2025111200001,
    "status": "pending",
    "create_time": "2025-11-12T10:30:00Z"
  }
}
```

#### 3.1.2 查询任务详情
```http
GET /api/v1/deduction/task/{task_id}

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 2025111200001,
    "name": "task_20251112_001",
    "status": "running",
    "scheme_id": 1234567890,
    "env_instance_id": 9876543210,
    "start_time": "2025-11-12T10:30:05Z",
    "total_agents": 2,
    "completed_agents": 0,
    "failed_agents": 0,
    "agent_executions": [
      {
        "id": 2025111200001,
        "agent_name": "RedTeamAgent",
        "status": "running",
        "progress": 45
      },
      {
        "id": 2025111200002,
        "agent_name": "BlueTeamAgent",
        "status": "pending",
        "progress": 0
      }
    ]
  }
}
```

#### 3.1.3 查询任务列表
```http
GET /api/v1/deduction/task/list?page=1&size=20&status=running

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "total": 50,
    "page": 1,
    "size": 20,
    "items": [...]
  }
}
```

#### 3.1.4 停止任务
```http
POST /api/v1/deduction/task/{task_id}/stop

Response:
{
  "code": 200,
  "message": "任务已停止",
  "data": {
    "task_id": 2025111200001,
    "status": "stopped"
  }
}
```

#### 3.1.5 更新任务配置
```http
PUT /api/v1/deduction/task/{task_id}/update
Content-Type: application/json

Request Body:
{
  "agent_configs": [
    {
      "agent_execution_id": 2025111200001,
      "params": {
        "attack_strategy": "stealth"  // 修改参数
      }
    }
  ]
}

Response:
{
  "code": 200,
  "message": "配置已更新",
  "data": {
    "updated_count": 1
  }
}
```

---

### 3.2 智能体执行接口

#### 3.2.1 查询智能体执行状态
```http
GET /api/v1/deduction/agent-execution/{execution_id}

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 2025111200001,
    "agent_name": "RedTeamAgent",
    "status": "running",
    "progress": 60,
    "start_time": "2025-11-12T10:30:05Z",
    "params": {...},
    "result": null
  }
}
```

#### 3.2.2 查询任务下的所有智能体
```http
GET /api/v1/deduction/task/{task_id}/agents?status=running

Response:
{
  "code": 200,
  "message": "success",
  "data": [
    {
      "id": 2025111200001,
      "agent_name": "RedTeamAgent",
      "status": "running",
      "progress": 60
    }
  ]
}
```

---

### 3.3 日志查询接口

#### 3.3.1 查询智能体日志
```http
GET /api/v1/deduction/agent-execution/{execution_id}/logs?level=ERROR&limit=100

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "total": 250,
    "logs": [
      {
        "id": 1,
        "timestamp": "2025-11-12T10:35:22Z",
        "level": "ERROR",
        "message": "Connection timeout",
        "source": "network_module"
      }
    ]
  }
}
```

#### 3.3.2 查询任务所有日志
```http
GET /api/v1/deduction/task/{task_id}/logs?start_time=2025-11-12T10:00:00Z&level=INFO

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "total": 1500,
    "logs": [...]
  }
}
```

---

### 3.4 历史记录接口

#### 3.4.1 查询任务变更历史
```http
GET /api/v1/deduction/task/{task_id}/history

Response:
{
  "code": 200,
  "message": "success",
  "data": [
    {
      "id": 1,
      "change_type": "config_update",
      "change_description": "修改攻击策略",
      "change_time": "2025-11-12T10:40:00Z",
      "old_value": {"attack_strategy": "aggressive"},
      "new_value": {"attack_strategy": "stealth"}
    }
  ]
}
```

---

## 四、Engine 服务交互设计

### 4.1 Engine API 假设

假设 Engine 服务提供以下接口（需根据实际调整）：

```http
# 1. 提交任务
POST /engine/task/submit
Request: {方案配置, 环境配置, 智能体列表}
Response: {engine_task_id}

# 2. 查询任务状态
GET /engine/task/{engine_task_id}/status
Response: {
  "status": "running",
  "agents": [
    {
      "engine_agent_id": "xxx",
      "status": "running",
      "progress": 60
    }
  ]
}

# 3. 查询智能体日志
GET /engine/agent/{engine_agent_id}/logs?since=timestamp
Response: {
  "logs": [
    {"timestamp": "...", "level": "INFO", "message": "..."}
  ]
}

# 4. 更新任务配置
PUT /engine/task/{engine_task_id}/update
Request: {更新的配置}

# 5. 停止任务
POST /engine/task/{engine_task_id}/stop
```

---

### 4.2 Engine 客户端封装

```python
# backend/app/deduction/engine_client.py

import httpx
from typing import Dict, List, Optional

class EngineClient:
    """Engine 服务客户端"""

    def __init__(self, base_url: str, timeout: int = 30):
        self.base_url = base_url
        self.client = httpx.AsyncClient(timeout=timeout)

    async def submit_task(
        self,
        scheme_data: dict,
        env_data: dict,
        agents: List[dict]
    ) -> str:
        """提交任务到 Engine"""
        response = await self.client.post(
            f"{self.base_url}/engine/task/submit",
            json={
                "scheme": scheme_data,
                "env": env_data,
                "agents": agents
            }
        )
        response.raise_for_status()
        return response.json()["engine_task_id"]

    async def get_task_status(self, engine_task_id: str) -> dict:
        """查询任务状态"""
        response = await self.client.get(
            f"{self.base_url}/engine/task/{engine_task_id}/status"
        )
        response.raise_for_status()
        return response.json()

    async def get_agent_logs(
        self,
        engine_agent_id: str,
        since: Optional[str] = None
    ) -> List[dict]:
        """查询智能体日志"""
        params = {"since": since} if since else {}
        response = await self.client.get(
            f"{self.base_url}/engine/agent/{engine_agent_id}/logs",
            params=params
        )
        response.raise_for_status()
        return response.json()["logs"]

    async def update_task(self, engine_task_id: str, updates: dict):
        """更新任务配置"""
        response = await self.client.put(
            f"{self.base_url}/engine/task/{engine_task_id}/update",
            json=updates
        )
        response.raise_for_status()

    async def stop_task(self, engine_task_id: str):
        """停止任务"""
        response = await self.client.post(
            f"{self.base_url}/engine/task/{engine_task_id}/stop"
        )
        response.raise_for_status()

    async def close(self):
        """关闭客户端"""
        await self.client.aclose()
```

---

## 五、定时任务实现方案

### 5.1 使用 APScheduler

#### 5.1.1 安装依赖
```bash
pip install apscheduler
```

#### 5.1.2 调度器配置

```python
# backend/core/scheduler.py

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from loguru import logger

scheduler = AsyncIOScheduler()

async def poll_running_tasks():
    """轮询运行中的任务"""
    from backend.app.deduction.service.task_monitor import TaskMonitor
    from backend.database.db import get_async_session

    try:
        async with get_async_session() as session:
            monitor = TaskMonitor(session)
            await monitor.poll_all_running_tasks()
    except Exception as e:
        logger.error(f"轮询任务失败: {e}")

def start_scheduler():
    """启动调度器"""
    scheduler.add_job(
        poll_running_tasks,
        trigger=IntervalTrigger(seconds=5),
        id="poll_running_tasks",
        replace_existing=True,
        max_instances=1  # 防止并发执行
    )
    scheduler.start()
    logger.info("任务调度器已启动")

def shutdown_scheduler():
    """关闭调度器"""
    scheduler.shutdown(wait=True)
    logger.info("任务调度器已关闭")
```

#### 5.1.3 集成到 FastAPI

```python
# backend/main.py

from backend.core.scheduler import start_scheduler, shutdown_scheduler

@app.on_event("startup")
async def startup_event():
    """应用启动事件"""
    # 启动调度器
    start_scheduler()
    logger.info("应用启动完成")

@app.on_event("shutdown")
async def shutdown_event():
    """应用关闭事件"""
    # 关闭调度器
    shutdown_scheduler()
    logger.info("应用已关闭")
```

---

### 5.2 任务监控服务

```python
# backend/app/deduction/service/task_monitor.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from loguru import logger
from datetime import datetime

from backend.app.deduction.model.deduction_task import DeductionTask
from backend.app.deduction.model.agent_execution import AgentExecution
from backend.app.deduction.crud.crud_agent_execution import agent_execution_crud
from backend.app.deduction.crud.crud_log import agent_log_crud
from backend.app.deduction.engine_client import EngineClient
from backend.core.conf import settings

class TaskMonitor:
    """任务监控器"""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.engine_client = EngineClient(settings.ENGINE_URL)

    async def poll_all_running_tasks(self):
        """轮询所有运行中的任务"""
        # 查询所有运行中的任务
        result = await self.session.execute(
            select(DeductionTask).where(DeductionTask.status == "running")
        )
        tasks = result.scalars().all()

        logger.info(f"发现 {len(tasks)} 个运行中的任务")

        for task in tasks:
            try:
                await self._poll_task(task)
            except Exception as e:
                logger.error(f"轮询任务 {task.id} 失败: {e}")

    async def _poll_task(self, task: DeductionTask):
        """轮询单个任务"""
        # 1. 调用 Engine API 获取状态
        status_data = await self.engine_client.get_task_status(task.engine_task_id)

        # 2. 更新智能体状态
        for agent_data in status_data.get("agents", []):
            await self._update_agent_status(task.id, agent_data)

        # 3. 获取并存储日志
        await self._fetch_agent_logs(task.id)

        # 4. 检查任务是否完成
        await self._check_task_completion(task)

    async def _update_agent_status(self, task_id: int, agent_data: dict):
        """更新智能体状态"""
        # 根据 engine_agent_id 查找执行实例
        result = await self.session.execute(
            select(AgentExecution).where(
                AgentExecution.deduction_task_id == task_id,
                AgentExecution.engine_agent_id == agent_data["engine_agent_id"]
            )
        )
        execution = result.scalar_one_or_none()

        if execution:
            # 更新状态
            execution.status = agent_data["status"]
            execution.progress = agent_data.get("progress", 0)

            if agent_data["status"] == "completed":
                execution.end_time = datetime.now()
                execution.result = agent_data.get("result")
            elif agent_data["status"] == "failed":
                execution.end_time = datetime.now()
                execution.error_message = agent_data.get("error")

            await self.session.commit()

    async def _fetch_agent_logs(self, task_id: int):
        """获取智能体日志"""
        # 查询所有运行中/待执行的智能体
        result = await self.session.execute(
            select(AgentExecution).where(
                AgentExecution.deduction_task_id == task_id,
                AgentExecution.status.in_(["pending", "running"])
            )
        )
        executions = result.scalars().all()

        for execution in executions:
            if not execution.engine_agent_id:
                continue

            try:
                # 获取最新日志时间戳
                last_log_time = await agent_log_crud.get_latest_log_time(
                    self.session, execution.id
                )

                # 调用 Engine API 获取日志
                logs = await self.engine_client.get_agent_logs(
                    execution.engine_agent_id,
                    since=last_log_time.isoformat() if last_log_time else None
                )

                # 批量插入日志
                for log in logs:
                    await agent_log_crud.create_log(
                        self.session,
                        agent_execution_id=execution.id,
                        timestamp=log["timestamp"],
                        level=log["level"],
                        message=log["message"],
                        extra_data=log.get("extra")
                    )

                await self.session.commit()
            except Exception as e:
                logger.error(f"获取智能体 {execution.id} 日志失败: {e}")

    async def _check_task_completion(self, task: DeductionTask):
        """检查任务是否完成"""
        # 统计智能体状态
        result = await self.session.execute(
            select(AgentExecution).where(
                AgentExecution.deduction_task_id == task.id
            )
        )
        executions = result.scalars().all()

        total = len(executions)
        completed = sum(1 for e in executions if e.status == "completed")
        failed = sum(1 for e in executions if e.status == "failed")

        # 更新任务统计信息
        task.total_agents = total
        task.completed_agents = completed
        task.failed_agents = failed

        # 检查是否全部完成
        if completed + failed == total:
            task.status = "completed" if failed == 0 else "failed"
            task.end_time = datetime.now()
            logger.info(f"任务 {task.id} 已完成")

        await self.session.commit()
```

---

## 六、开发步骤

### 阶段 1: 数据模型和基础架构 (2-3天)

**任务清单**:
- [ ] 创建数据模型 (model/)
  - [ ] deduction_task.py
  - [ ] agent_execution.py
  - [ ] agent_execution_log.py
  - [ ] deduction_task_history.py
- [ ] 创建 Pydantic Schema (schema/)
  - [ ] task_schema.py
  - [ ] agent_execution_schema.py
  - [ ] log_schema.py
- [ ] 创建 CRUD 层 (crud/)
  - [ ] crud_task.py
  - [ ] crud_agent_execution.py
  - [ ] crud_log.py
- [ ] 数据库迁移（如果使用 Alembic）

---

### 阶段 2: Engine 客户端和核心服务 (3-4天)

**任务清单**:
- [ ] 实现 Engine 客户端 (engine_client.py)
  - [ ] submit_task
  - [ ] get_task_status
  - [ ] get_agent_logs
  - [ ] update_task
  - [ ] stop_task
- [ ] 实现核心服务 (service/)
  - [ ] task_service.py (创建、查询、更新、停止任务)
  - [ ] agent_execution_service.py (智能体状态管理)
  - [ ] log_service.py (日志查询)
- [ ] 配置管理
  - [ ] 在 conf.py 中添加 ENGINE_URL 等配置

---

### 阶段 3: 定时任务和监控 (2-3天)

**任务清单**:
- [ ] 配置 APScheduler (core/scheduler.py)
- [ ] 实现任务监控器 (service/task_monitor.py)
  - [ ] 轮询运行中任务
  - [ ] 更新智能体状态
  - [ ] 获取和存储日志
  - [ ] 检查任务完成
- [ ] 集成到 FastAPI 生命周期
- [ ] 添加监控日志和错误处理

---

### 阶段 4: API 接口开发 (3-4天)

**任务清单**:
- [ ] 任务管理 API (api/task_api.py)
  - [ ] POST /create
  - [ ] GET /{id}
  - [ ] GET /list
  - [ ] POST /{id}/stop
  - [ ] PUT /{id}/update
- [ ] 智能体执行 API (api/agent_execution_api.py)
  - [ ] GET /{execution_id}
  - [ ] GET /task/{task_id}/agents
- [ ] 日志查询 API (api/log_api.py)
  - [ ] GET /{execution_id}/logs
  - [ ] GET /task/{task_id}/logs
- [ ] 历史记录 API (api/history_api.py)
  - [ ] GET /task/{task_id}/history

---

### 阶段 5: 测试和优化 (2-3天)

**任务清单**:
- [ ] 单元测试
  - [ ] CRUD 层测试
  - [ ] Service 层测试
- [ ] 集成测试
  - [ ] API 端到端测试
  - [ ] Engine 交互测试（Mock）
- [ ] 性能优化
  - [ ] 数据库查询优化
  - [ ] 批量操作优化
  - [ ] 日志查询分页优化
- [ ] 错误处理完善
  - [ ] Engine 不可用处理
  - [ ] 数据库异常处理
  - [ ] 超时处理

---

## 七、配置说明

### 7.1 环境变量

在 `.env` 文件中添加：

```bash
# Engine 服务配置
ENGINE_URL=http://localhost:8080
ENGINE_TIMEOUT=30

# 任务监控配置
TASK_POLL_INTERVAL=5  # 轮询间隔（秒）
TASK_POLL_ENABLED=true  # 是否启用任务轮询

# 日志配置
LOG_RETENTION_DAYS=30  # 日志保留天数
LOG_BATCH_SIZE=100  # 日志批量插入大小
```

### 7.2 配置类更新

```python
# backend/core/conf.py

class Settings(BaseSettings):
    # ... 现有配置 ...

    # Engine 配置
    ENGINE_URL: str = "http://localhost:8080"
    ENGINE_TIMEOUT: int = 30

    # 任务监控配置
    TASK_POLL_INTERVAL: int = 5
    TASK_POLL_ENABLED: bool = True

    # 日志配置
    LOG_RETENTION_DAYS: int = 30
    LOG_BATCH_SIZE: int = 100
```

---

## 八、风险和注意事项

### 8.1 技术风险

1. **Engine 服务依赖**
   - 风险：Engine 服务不可用导致任务创建失败
   - 缓解：添加重试机制、健康检查、降级策略

2. **大量日志存储**
   - 风险：日志表快速膨胀
   - 缓解：定期清理历史日志、分表存储、考虑使用 Elasticsearch

3. **定时任务并发**
   - 风险：轮询任务重叠执行
   - 缓解：设置 `max_instances=1`、添加分布式锁

4. **数据库性能**
   - 风险：高频查询和更新影响性能
   - 缓解：优化索引、使用批量操作、考虑 Redis 缓存

---

### 8.2 业务风险

1. **方案配置快照**
   - 风险：原方案修改后历史任务无法追溯
   - 缓解：在 deduction_task 中存储完整方案快照

2. **任务状态一致性**
   - 风险：后端状态与 Engine 状态不一致
   - 缓解：定期同步、提供手动同步接口

3. **日志丢失**
   - 风险：网络异常导致日志未及时获取
   - 缓解：记录最后日志时间戳、支持补偿查询

---

## 九、后续扩展

### 9.1 可选功能

1. **WebSocket 实时推送**
   - 使用 FastAPI WebSocket 向前端推送实时状态
   - 减少前端轮询压力

2. **任务队列**
   - 使用 Celery 或 RQ 处理异步任务
   - 支持任务优先级

3. **资源监控**
   - 监控 Engine 服务的 CPU/内存使用
   - 智能调度任务

4. **智能重试**
   - 失败智能体自动重试
   - 可配置重试策略

---

## 十、总结

本开发计划涵盖了 Deduction 模块的完整设计和实现路线，主要包括：

- **4 张核心数据表**：deduction_task、agent_execution、agent_execution_log、deduction_task_history
- **完整的 API 接口**：任务管理、状态查询、日志查询
- **定时监控机制**：基于 APScheduler 的任务轮询
- **Engine 服务集成**：完整的客户端封装和错误处理

预计总工期 **2-3 周**，分为 5 个阶段逐步实现。

---

**文档版本**: v1.0
**最后更新**: 2025-11-12
**负责人**: [待填写]
**审核人**: [待填写]
